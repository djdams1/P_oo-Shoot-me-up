<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title id="page-title">Journal de travail par GitHub</title>
    <link rel="icon" type="image/png" href="icon.png" />
    <script src="exceptions.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }

      input,
      button {
        margin: 5px 0;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }

      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }

      th {
        background-color: #f4f4f4;
      }

      ul,
      ol,
      li {
        margin: 13px;
      }

      .patched {
        background-color: cornsilk;
      }

      .linked {
        cursor: pointer;
      }

      .date-header {
        font-weight: bold;
        font-size: 1.2em;
        margin-top: 20px;
      }

      .d-none {
        display: none;
      }

      .topButton {
        border: 1px solid black;
        border-radius: 50%;
        height: 20px;
        width: 20px;
        padding: 5px;
        text-align: center;
        background-color: lightgray;
        float: right;
        cursor: pointer;
        margin-left: 10px;
      }

      @media print {
        .no-print,
        .no-print * {
          display: none !important;
        }
      }
    </style>
    <!-- Pour le formulaire de saisie -->
    <style>
      body {
        font-family: sans-serif;
        margin: 0;
        padding: 2rem;
      }
      button {
        padding: 0.6rem 1rem;
        font-size: 1rem;
        cursor: pointer;
      }
      /* Overlay caché par défaut */
      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(0, 0, 0, 0.7);
        justify-content: center;
        align-items: center;
      }
      .overlay.active {
        display: flex;
      }
      /* Effet spotlight */
      .overlay::before {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle 200px at center, transparent 0, transparent 200px, rgba(0, 0, 0, 0.7) 210px);
      }
      .modal {
        position: relative;
        background: white;
        color: black;
        padding: 1rem;
        border-radius: 8px;
        max-width: 400px;
        width: 100%;
        z-index: 1; /* au-dessus de l'overlay */
      }
      .modal h2 {
        margin-top: 0;
      }
      label {
        display: block;
        margin: 0.5rem;
      }
      input,
      textarea,
      select {
        width: 100%;
        padding: 0.4rem;
        margin-top: 0.2rem;
      }
      .actions {
        margin-top: 1rem;
        text-align: right;
      }
    </style>
  </head>

  <body>
    <div id="divHelpButton" class="topButton no-print" onclick="toggleHelp()">?</div>
    <div id="divAddButton" class="topButton no-print" onclick="toggleHelp()">+</div>
    <h1 id="project-title">Journal de travail extrait de commits GitHub</h1>
    <div id="inputZone">
      <div id="defaultMode" class="d-none">
        <div id="txtDefaultRepo"></div>
      </div>
      <div id="singleMode" class="d-none">
        <span style="width: 80px">URL du repo :</span>
        <input type="text" id="repoUrl" placeholder="https://github.com/utilisateur/repository" style="width: 500px" />
      </div>
      <div id="selectMode" class="d-none">
        <select id="dpdProjects"></select>
      </div>
      <br />
      <br />
      <div id="divBranchSelection" class="d-none">
        <span style="width: 80px">Branche :</span>
        <select id="dpdBranches"></select>
      </div>
      <br />
      <button id="cmdGo" onclick="fetchGitLogs()" class="d-none">Ok</button>
    </div>
    <div id="logs"></div>
    <div id="errors" class="no-print d-none"></div>
    <div id="divHelp" class="d-none">
      <h3>Git journal</h3>
      <p>Cet outil vous permet de générer un journal de travail basé sur le log d'un repo Git</p>
      <p>Voici comment l'utiliser :</p>
      <ul>
        <li>
          Appliquer la règle suivante : <span style="font-weight: bolder">toute activité laisse une trace</span>. Cela
          est également vrai pour des moments d'apprentissage ou d'écoute :
        </li>
        <ul>
          <li>Si on a codé, la trace c'est bien sur le code</li>
          <li>
            Si on a fait de la documentation, la trace est une nouvelle version du rapport ou de toute autre document
          </li>
          <li>Si on a assisté à une réunion, la trace, c'est le procès-verbal de la réunion</li>
          <li>
            Si on a écouté une explication, visionné un tutoriel ou lu un article ou une documentation, la trace c'est
            les notes qui résument ce qu'on a appris
          </li>
        </ul>
        <li>
          Pour chaque commit Git, vous fournissez les données nécessaires à la construction du journal au moyen de
          champs dont la valeur est indiquée entre crochets carrés []. Il y a trois types de champs possibles:
          <ol>
            <li>
              La durée (obligatoire). Le temps qu'il vous a fallu pour produire le contenu de ce commit. Il peut être
              exprimé en minutes ou en heure et minute. Exemples de valeur possible : [45], [45min], [1h20], [80m]
            </li>
            <li>
              Le status de la tâche (obligatoire). Le format est libre, mais par convention nous n'utilisons que [WIP]
              (pour une tâche inachevée) et [DONE].
            </li>
            <li>
              Une date corrective (facultative), pour rattraper une erreur si par exemple on a fait un commit la semaine
              précédente et que l'on a oublié de fournir les informations. Exemple : j'ai fait un commit le 12 janvier
              2024 dont l'effet est de rajouter un bouton d'aide au gitjournal, mais j'ai oublié de préciser la durée et
              le status. Le 15 janvier 2024, je fais un commit vide
              <div style="font-family: 'Courier New'; padding: 5px">
                git commit --allow-empty -m "feat(gitjournal): Ajouter un bouton d'aide" -m "[30m][DONE][2024-01-15]"
              </div>
              Ce commit aura pour effet de faire apparaître mon travail du 12 janvier au bon endroit dans le journal.
            </li>
          </ol>
        </li>
        <li>
          Renommez le fichier <span style="font-family: 'Courier New'">.config.js.example</span> en
          <span style="font-family: 'Courier New'">.config.js</span>
        </li>
        <li>
          Générez un Git Personal Access Token (<a href="https://github.com/settings/tokens">PAT</a>) et placez-le dans
          <span style="font-family: 'Courier New'">.config.js</span><br />
          <span style="font-weight: bold">Attention:</span> Veillez à ce que votre token aie bien la portée "repo" (voir
          image ci-dessous)<br />
        </li>
        <li>
          Optionnellement, vous pouvez configurer dans
          <span style="font-family: 'Courier New'">.config.js.example</span> un repo qui sera pris par défaut et/ou une
          liste de repos avec lesquelles vous travaillez actuellement
        </li>
        <li>Cliquez sur une des entrées du journal pour atteindre le commit correspondant</li>
        <li>Pour une version PDF, il vous suffit d'"imprimer" cette page</li>
      </ul>
      <h4>Génération du PAT</h4>
      <img width="800px" src="./generatePAT.png" />
    </div>
    <div class="overlay" id="overlay">
      <div class="modal">
        <h2 id="heaInputForm">Saisie manuelle</h2>
        <form id="dataForm">
          <label
            >Nom
            <input type="text" name="name" id="txtName" />
          </label>
          <label
            >Description
            <textarea name="description" id="txtDescription"></textarea>
          </label>
          <label
            >Date
            <input type="datetime-local" name="date" id="datDate" />
          </label>
          <label
            >Durée (minutes)
            <input type="number" name="duration" id="numDuration" />
          </label>
          <label
            >Statut
            <select name="status" id="dpdStatus">
              <option selected>Done</option>
              <option>WIP</option>
            </select>
          </label>
          <div class="actions">
            <button type="button" id="closeBtn">Annuler</button>
            <button type="button" id="saveBtn">Enregistrer</button>
          </div>
          <input type="hidden" id="hidSHA" name="sha" />
        </form>
      </div>
    </div>
  </body>
</html>

<script src=".config.js"></script>
<script>
  var filteringUsers = []; // the github user names to take into account as committers
  var repoOwner = "?"; // the owner of the selected repo
  var myCommits = [];

  configure();

  async function configure() {
    /// Initialize inputs with defaults from config file
    if (typeof defaultRepo != "undefined") {
      defaultMode.classList.remove("d-none");
      txtDefaultRepo.innerText = typeof defaultRepo.alias != "undefined" ? defaultRepo.alias : defaultRepo.url;
      repoUrl.value = defaultRepo.url;
      await fetchGitBranches();
      filteringUsers.push(repoOwner);
      if (typeof defaultRepo.users != "undefined") filteringUsers.push(...defaultRepo.users);
    } else if (typeof repos != "undefined") {
      selectMode.classList.remove("d-none");
      initDropdown();
    } else {
      singleMode.classList.remove("d-none");
      repoUrl.addEventListener("change", loadSingle);
    }
  }

  async function fetchGitLogs() {
    const repoUrl = document.getElementById("repoUrl").value || defaultRepoUrl;
    const authToken = defaultAuthToken;
    const logsDiv = document.getElementById("logs");
    const errorsDiv = document.getElementById("errors");
    logsDiv.innerHTML = ""; // Effacer les anciens logs

    // Extraire l'utilisateur et le nom du repository depuis l'URL
    const repoMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
    if (!repoMatch) {
      logsDiv.innerHTML = '<p style="color: red;">URL du repository GitHub invalide.</p>';
      return;
    }
    const [_, owner, repo] = repoMatch;

    document.getElementById("inputZone").classList.add("d-none");

    try {
      const branch = dpdBranches.value || "main";
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/commits?sha=${branch}`;
      // Mise à jour des titres
      document.getElementById("page-title").innerText = `Journal de ${filteringUsers.join(", ")} pour ${repo}`;
      document.getElementById("project-title").innerText = `Journal de ${filteringUsers.join(", ")} pour ${repo}`;

      // Récupérer les commits depuis l'API GitHub

      const allCommits = await getAllCommits(owner, repo, branch, defaultAuthToken);

      if (allCommits.length === 0) {
        logsDiv.innerHTML = "<p>Aucun commit trouvé pour la branche spécifiée.</p>";
        return;
      }

      // Apply patches to existing commits
      const patches = exceptions.filter((c) => typeof c.sha != "undefined");
      patches.forEach((patch) => {
        const commit = allCommits.find((c) => c.sha == patch.sha);
        if (commit) {
          commit.patch = true;
          if (typeof patch.name != "undefined") commit.name = patch.name;
          if (typeof patch.description != "undefined") commit.description = patch.description;
          if (typeof patch.date != "undefined") commit.date = patch.date;
          if (typeof patch.duration != "undefined") commit.duration = parseInt(patch.duration);
          if (typeof patch.status != "undefined") commit.status = patch.status;
        }
      });

      // Add exceptions without commit (i.e: completely manual entries of the journal)
      const nocommitref = exceptions.filter((c) => typeof c.sha == "undefined");
      const allCommitsSorted = nocommitref.concat(allCommits).sort((a, b) => new Date(a.date) - new Date(b.date));
      myCommits = allCommitsSorted.filter((c) => filteringUsers.includes(c.author));

      const errors = []; // Commits that don't comply
      // Regrouper les commits par date
      const commitsByDate = {};
      let fiCommits = false;
      myCommits.forEach((commit) => {
        if (typeof journalStartDate != "undefined" && commit.date < journalStartDate) {
          return; // Ignore les commits qui ne sont pas dans la période spécifiée
        }
        let datekey = new Date(commit.date).toLocaleDateString("fr-FR", {
          year: "numeric",
          month: "long",
          day: "numeric"
        });
        if (!commitsByDate[datekey]) {
          commitsByDate[datekey] = [];
        }
        commitsByDate[datekey].push(commit);
        fiCommits = true;
      });

      if (!fiCommits) {
        logsDiv.innerHTML = '<p style="color: red;">Aucun commit significatif a été trouvé</p>';
        if (typeof username != "undefined")
          logsDiv.innerHTML += '<p style="color: red;">Utilisateur recherché: ' + username + "</p>";
        if (typeof journalStartDate != "undefined")
          logsDiv.innerHTML += '<p style="color: red;">Date de début: ' + journalStartDate + "</p>";
        return;
      }

      const headerRow =
        filteringUsers.length > 1
          ? `
        <tr>
          <th style="width:25%;">Tâche</th>
          <th style="width:55%;">Description</th>
          <th style="width:5%;">Durée</th>
          <th style="width:5%;">Status</th>
          <th style="width:10%;">User</th>
          </tr>`
          : `
        <tr>
          <th style="width:30%;">Tâche</th>
          <th style="width:60%;">Description</th>
          <th style="width:5%;">Durée</th>
          <th style="width:5%;">Status</th>
          </tr>`;

      // Créer le tableau pour chaque jour
      for (const date in commitsByDate) {
        let showIt = false;
        let totalDurationInMinutes = 0;
        const table = document.createElement("table");
        table.innerHTML = headerRow;
        table.addEventListener("click", (e) => {
          const tr = e.target.closest("tr.linked");
          if (!tr) return; // clique sur une ligne non cliquable
          const sha = tr.dataset.sha;
          if (!sha) return;
          if (e.shiftKey) {
            editCommit(sha);
          } else {
            window.open(`${repoUrl}/commit/${sha}`, "_blank");
          }
        });
        commitsByDate[date].forEach((commit) => {
          showIt = true;
          totalDurationInMinutes += commit.duration;

          // Add row to table
          const newRow = document.createElement("tr");
          if (commit.patch) newRow.classList.add("patched");
          if (typeof commit.sha == "undefined") {
            newRow.classList.add("patched");
          } else {
            newRow.classList.add("linked");
            newRow.dataset.sha = commit.sha;
            newRow.addEventListener("click", () => {
              window.open(repoUrl + "/commit/" + commit.sha, "_blank");
            });
          }
          newRow.innerHTML =
            filteringUsers.length > 1
              ? `
                    <td>${commit.name}</td>
                    <td>${commit.description}</td> <!-- Si pas de description, la cellule reste vide -->
                    <td>${toHours(commit.duration)}</td>
                    <td>${commit.status}</td>
                    <td>${commit.author}</td>
                `
              : `
                    <td>${commit.name}</td>
                    <td>${commit.description}</td> <!-- Si pas de description, la cellule reste vide -->
                    <td>${toHours(commit.duration)}</td>
                    <td>${commit.status}</td>
                `;
          table.appendChild(newRow);
        });

        if (showIt) {
          // Ajouter la ligne de total à la table
          const totalRow = `
              <tr>
                  <td></td>
                  <td style="text-align: right; font-weight: bold;">Total :</td>
                  <td style="font-weight: bold;">${toHours(totalDurationInMinutes)}</td>
                  <td></td>
              </tr>`;
          table.innerHTML += totalRow;
          // Ajouter un en-tête pour la date et le tableau
          const dateHeader = document.createElement("div");
          dateHeader.className = "date-header";
          dateHeader.textContent = `${date}`;
          logsDiv.appendChild(dateHeader);
          logsDiv.appendChild(table);
        }
      }
      // Show errors
      if (errors.length > 0) {
        errorsDiv.innerHTML =
          "<h4>Les commits suivants ont été ignorés, probalement parce qu'ils ne respectent pas la convention</h4>";
        errorsDiv.innerHTML += errors.join("<br>");
        errorsDiv.classList.remove("d-none");
      }
    } catch (error) {
      logsDiv.innerHTML = `<p style="color: red;">Erreur : ${error.message}</p>`;
    }
  }

  async function getAllCommits(owner, repo, branch, authToken) {
    let page = 1;
    let hasMore = true;
    let res = [];

    while (hasMore) {
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/commits?sha=${branch}&per_page=100&page=${page}`;

      const response = await fetch(apiUrl, {
        headers: { Authorization: `Bearer ${authToken}` }
      });

      if (!response.ok) {
        console.error("Erreur lors de la récupération des commits:", response.status);
        return;
      }

      const commits = await response.json();
      res = res.concat(commits);
      if (commits.length < 100) {
        hasMore = false; // S'il y a moins de 100 commits, c'est la dernière page
      } else {
        if (commits[99].commit.author.date < journalStartDate) {
          hasMore = false; // Si la date du commit est antérieure à journalStartDate, on arrête
        }
        page++;
      }
    }
    return res.map((c) => groom(c));
  }
  /// Extracts information from the commit description and make them available as fields of the commit object
  function groom(commit) {
    let duration = 0;
    let status = "";
    const messageBreakdown = commit.commit.message.split("\n").filter((line) => line.trim() !== "");
    if (messageBreakdown.length > 1) {
      // can be a valid journal entry
      // Extraction des champs de métadonnées
      const regex = /\[(.*?)\]/g;
      const meta = Array.from(messageBreakdown[1].matchAll(regex), (match) => match[1]);
      // Handle duration
      if (meta && meta.length >= 2) {
        // valid journal data
        // Analyse duration
        // trickytricky... a field without numbers is status, with 1 or 2 numbers it's a duration, with 3 it's a date correction
        meta.forEach((m) => {
          let numericparts = m.match(/\d+/g);
          if (numericparts == null) {
            status = m;
          } else if (numericparts.length < 3) {
            numericparts.forEach((p) => (duration = duration * 60 + parseInt(p)));
          }
        });
      }
    }
    return {
      sha: commit.sha,
      name: messageBreakdown[0],
      description: messageBreakdown.slice(2).join("<br>"), // Le reste comme description
      date: commit.commit.author.date,
      duration: duration,
      status: status,
      author: commit.author.login
    };
  }

  function editCommit(sha) {
    heaInputForm.innerText = "Corriger une entrée";
    txtName.disabled = true;
    dpdStatus.disabled = true;
    hidSHA.value = sha;
    overlay.classList.add("active");
  }
  /// Prepare the repos selection dropdown
  function initDropdown() {
    if (typeof repos != "undefined" && repos.length > 0) {
      dpdProjects.innerHTML =
        `<option>--- Choisir ---</option>` +
        repos.map((r) => `<option value=${r.url}>${r.alias ? r.alias : "r.url"}</option>`);
    } else {
      cmdGo.classList.remove("d-none");
    }

    // Launch action on change
    dpdProjects.addEventListener("change", async () => {
      repoUrl.value = dpdProjects.value;
      await fetchGitBranches();
      const selectedRepo = repos.find((r) => r.url == dpdProjects.value);
      filteringUsers.push(repoOwner);
      if (typeof selectedRepo.users != "undefined") filteringUsers.push(...selectedRepo.users);
    });
  }

  async function fetchGitBranches() {
    const repoUrl = document.getElementById("repoUrl").value || defaultRepoUrl;
    const authToken = defaultAuthToken;
    // Extraire l'utilisateur et le nom du repository depuis l'URL
    const repoMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
    let repo;
    try {
      const [_, o, r] = repoMatch;
      repoOwner = o;
      repo = r;
    } catch {
      return;
    }
    const branchUrl = `https://api.github.com/repos/${repoOwner}/${repo}/branches`;
    // Récupérer les branches depuis l'API GitHub
    const response = await fetch(branchUrl, {
      headers: {
        Authorization: `Bearer ${authToken}`,
        Accept: "application/vnd.github.v3+json"
      }
    });
    if (!response.ok) {
      throw new Error(`Échec de la récupération des branches : ${response.status} ${response.statusText}`);
    }
    const branches = await response.json();
    dpdBranches.innerHTML = branches.map((b) => "<option>" + b.name + "</option>").join();
    divBranchSelection.classList.remove("d-none");
    cmdGo.classList.remove("d-none");
  }
  /// Converts number of minutes into nicely formatted string

  /// Load a repo from url manual input
  async function loadSingle() {
    await fetchGitBranches();
    filteringUsers.push(repoOwner);
  }
  function toHours(minutes) {
    return Math.floor(minutes / 60) + "h" + (minutes % 60).toString().padStart(2, "0") + "m";
  }

  /// Hide/show help
  function toggleHelp() {
    divHelp.classList.toggle("d-none");
  }
</script>
<script>
  function saveData(data) {
    const jsonStr = "const exceptions = " + JSON.stringify(data, null, 2); // null, 2 = joli format

    // Création d’un blob JSON
    const blob = new Blob([jsonStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    // Création du lien de téléchargement
    const a = document.createElement("a");
    a.href = url;
    a.download = "exceptions.js";
    a.click();

    // Nettoyage
    URL.revokeObjectURL(url);
  }
</script>
<script>
  // Input form
  const openBtn = document.getElementById("divAddButton");
  const closeBtn = document.getElementById("closeBtn");
  const overlay = document.getElementById("overlay");
  const dateInput = document.querySelector('input[name="date"]');

  openBtn.onclick = () => {
    heaInputForm.innerText = "Ajout d'une entrée";
    txtName.disabled = false;
    dpdStatus.disabled = false;
    overlay.classList.add("active");
  };
  closeBtn.onclick = () => overlay.classList.remove("active");
  overlay.onclick = (e) => {
    if (e.target === overlay) overlay.classList.remove("active");
  };

  saveBtn.onclick = () => {
    const fd = new FormData(dataForm);
    const sha = fd.get("sha");
    if (sha) {
      let patch = { sha: sha };
      const patchdescription = fd.get("description");
      const patchdate = fd.get("date");
      const patchduration = fd.get("duration");
      if (patchdescription) patch.description = patchdescription;
      if (patchdate) patch.date = patchdate;
      if (patchduration) patch.duration = patchduration;
      exceptions.push(patch);
    } else {
      exceptions.push({
        patch: true,
        name: fd.get("name"),
        description: fd.get("description"),
        date: new Date(fd.get("date")).toISOString(),
        duration: Number(fd.get("duration")),
        status: fd.get("status"),
        author: repoOwner
      });
    }
    saveData(exceptions);
    overlay.classList.remove("active");
  };
</script>
